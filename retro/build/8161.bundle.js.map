{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/observablestring.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/undoablelist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/modeldb.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/observablejson.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/observablelist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/observables/lib/observablemap.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/shared-models/lib/utils.js"],"names":["ObservableString","initialText","this","_text","_isDisposed","_changed","Signal","value","length","emit","type","start","end","index","text","slice","oldValue","clear","ObservableUndoableList","serializer","super","_inCompound","_isUndoable","_madeCompoundChange","_index","_stack","_serializer","changed","connect","_onListChanged","isUndoAble","canUndo","changes","change","reverse","_undoChange","canRedo","_redoChange","list","isDisposed","evt","_copyChange","push","each","newValues","remove","newIndex","oldIndex","oldValues","set","fromJSON","insert","move","toJSON","IdentitySerializer","ObservableValue","initialValue","_value","JSONExt","newValue","IChangedArgs","ModelDB","options","isPrepopulated","isCollaborative","connected","Promise","resolve","_toDispose","_disposables","DisposableSet","_basePath","basePath","baseDB","_db","path","get","_resolvePath","has","str","add","vec","map","val","Error","view","dispose","ObservableJSON","itemCmp","values","out","Object","create","keys","key","undefined","ChangeMessage","Message","args","Private","ObservableList","_array","_itemCmp","ArrayIterator","num","ArrayExt","item","copy","fromIndex","toIndex","toArray","startIndex","endIndex","i","first","second","ObservableMap","_map","Map","size","oldVal","keyList","forEach","v","k","valList","delete","createMutex","token","f"],"mappings":"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","file":"8161.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A concrete implementation of [[IObservableString]]\n */\nexport class ObservableString {\n    /**\n     * Construct a new observable string.\n     */\n    constructor(initialText = '') {\n        this._text = '';\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        this._text = initialText;\n    }\n    /**\n     * The type of the Observable.\n     */\n    get type() {\n        return 'String';\n    }\n    /**\n     * A signal emitted when the string has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Set the value of the string.\n     */\n    set text(value) {\n        if (value.length === this._text.length && value === this._text) {\n            return;\n        }\n        this._text = value;\n        this._changed.emit({\n            type: 'set',\n            start: 0,\n            end: value.length,\n            value: value\n        });\n    }\n    /**\n     * Get the value of the string.\n     */\n    get text() {\n        return this._text;\n    }\n    /**\n     * Insert a substring.\n     *\n     * @param index - The starting index.\n     *\n     * @param text - The substring to insert.\n     */\n    insert(index, text) {\n        this._text = this._text.slice(0, index) + text + this._text.slice(index);\n        this._changed.emit({\n            type: 'insert',\n            start: index,\n            end: index + text.length,\n            value: text\n        });\n    }\n    /**\n     * Remove a substring.\n     *\n     * @param start - The starting index.\n     *\n     * @param end - The ending index.\n     */\n    remove(start, end) {\n        const oldValue = this._text.slice(start, end);\n        this._text = this._text.slice(0, start) + this._text.slice(end);\n        this._changed.emit({\n            type: 'remove',\n            start: start,\n            end: end,\n            value: oldValue\n        });\n    }\n    /**\n     * Set the ObservableString to an empty string.\n     */\n    clear() {\n        this.text = '';\n    }\n    /**\n     * Test whether the string has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the string.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this.clear();\n    }\n}\n//# sourceMappingURL=observablestring.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { each } from '@lumino/algorithm';\nimport { ObservableList } from './observablelist';\n/**\n * A concrete implementation of an observable undoable list.\n */\nexport class ObservableUndoableList extends ObservableList {\n    /**\n     * Construct a new undoable observable list.\n     */\n    constructor(serializer) {\n        super();\n        this._inCompound = false;\n        this._isUndoable = true;\n        this._madeCompoundChange = false;\n        this._index = -1;\n        this._stack = [];\n        this._serializer = serializer;\n        this.changed.connect(this._onListChanged, this);\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    get canRedo() {\n        return this._index < this._stack.length - 1;\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    get canUndo() {\n        return this._index >= 0;\n    }\n    /**\n     * Begin a compound operation.\n     *\n     * @param isUndoAble - Whether the operation is undoable.\n     *   The default is `true`.\n     */\n    beginCompoundOperation(isUndoAble) {\n        this._inCompound = true;\n        this._isUndoable = isUndoAble !== false;\n        this._madeCompoundChange = false;\n    }\n    /**\n     * End a compound operation.\n     */\n    endCompoundOperation() {\n        this._inCompound = false;\n        this._isUndoable = true;\n        if (this._madeCompoundChange) {\n            this._index++;\n        }\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        if (!this.canUndo) {\n            return;\n        }\n        const changes = this._stack[this._index];\n        this._isUndoable = false;\n        for (const change of changes.reverse()) {\n            this._undoChange(change);\n        }\n        this._isUndoable = true;\n        this._index--;\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        if (!this.canRedo) {\n            return;\n        }\n        this._index++;\n        const changes = this._stack[this._index];\n        this._isUndoable = false;\n        for (const change of changes) {\n            this._redoChange(change);\n        }\n        this._isUndoable = true;\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndo() {\n        this._index = -1;\n        this._stack = [];\n    }\n    /**\n     * Handle a change in the list.\n     */\n    _onListChanged(list, change) {\n        if (this.isDisposed || !this._isUndoable) {\n            return;\n        }\n        // Clear everything after this position if necessary.\n        if (!this._inCompound || !this._madeCompoundChange) {\n            this._stack = this._stack.slice(0, this._index + 1);\n        }\n        // Copy the change.\n        const evt = this._copyChange(change);\n        // Put the change in the stack.\n        if (this._stack[this._index + 1]) {\n            this._stack[this._index + 1].push(evt);\n        }\n        else {\n            this._stack.push([evt]);\n        }\n        // If not in a compound operation, increase index.\n        if (!this._inCompound) {\n            this._index++;\n        }\n        else {\n            this._madeCompoundChange = true;\n        }\n    }\n    /**\n     * Undo a change event.\n     */\n    _undoChange(change) {\n        let index = 0;\n        const serializer = this._serializer;\n        switch (change.type) {\n            case 'add':\n                each(change.newValues, () => {\n                    this.remove(change.newIndex);\n                });\n                break;\n            case 'set':\n                index = change.oldIndex;\n                each(change.oldValues, value => {\n                    this.set(index++, serializer.fromJSON(value));\n                });\n                break;\n            case 'remove':\n                index = change.oldIndex;\n                each(change.oldValues, value => {\n                    this.insert(index++, serializer.fromJSON(value));\n                });\n                break;\n            case 'move':\n                this.move(change.newIndex, change.oldIndex);\n                break;\n            default:\n                return;\n        }\n    }\n    /**\n     * Redo a change event.\n     */\n    _redoChange(change) {\n        let index = 0;\n        const serializer = this._serializer;\n        switch (change.type) {\n            case 'add':\n                index = change.newIndex;\n                each(change.newValues, value => {\n                    this.insert(index++, serializer.fromJSON(value));\n                });\n                break;\n            case 'set':\n                index = change.newIndex;\n                each(change.newValues, value => {\n                    this.set(change.newIndex++, serializer.fromJSON(value));\n                });\n                break;\n            case 'remove':\n                each(change.oldValues, () => {\n                    this.remove(change.oldIndex);\n                });\n                break;\n            case 'move':\n                this.move(change.oldIndex, change.newIndex);\n                break;\n            default:\n                return;\n        }\n    }\n    /**\n     * Copy a change as JSON.\n     */\n    _copyChange(change) {\n        const oldValues = [];\n        each(change.oldValues, value => {\n            oldValues.push(this._serializer.toJSON(value));\n        });\n        const newValues = [];\n        each(change.newValues, value => {\n            newValues.push(this._serializer.toJSON(value));\n        });\n        return {\n            type: change.type,\n            oldIndex: change.oldIndex,\n            newIndex: change.newIndex,\n            oldValues,\n            newValues\n        };\n    }\n}\n/**\n * Namespace for ObservableUndoableList utilities.\n */\n(function (ObservableUndoableList) {\n    /**\n     * A default, identity serializer.\n     */\n    class IdentitySerializer {\n        /**\n         * Identity serialize.\n         */\n        toJSON(value) {\n            return value;\n        }\n        /**\n         * Identity deserialize.\n         */\n        fromJSON(value) {\n            return value;\n        }\n    }\n    ObservableUndoableList.IdentitySerializer = IdentitySerializer;\n})(ObservableUndoableList || (ObservableUndoableList = {}));\n//# sourceMappingURL=undoablelist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DisposableSet } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nimport { JSONExt } from '@lumino/coreutils';\nimport { ObservableMap } from './observablemap';\nimport { ObservableJSON } from './observablejson';\nimport { ObservableString } from './observablestring';\nimport { ObservableUndoableList } from './undoablelist';\n/**\n * A concrete implementation of an `IObservableValue`.\n */\nexport class ObservableValue {\n    /**\n     * Constructor for the value.\n     *\n     * @param initialValue: the starting value for the `ObservableValue`.\n     */\n    constructor(initialValue = null) {\n        this._value = null;\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this._value = initialValue;\n    }\n    /**\n     * The observable type.\n     */\n    get type() {\n        return 'Value';\n    }\n    /**\n     * Whether the value has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Get the current value, or `undefined` if it has not been set.\n     */\n    get() {\n        return this._value;\n    }\n    /**\n     * Set the current value.\n     */\n    set(value) {\n        const oldValue = this._value;\n        if (JSONExt.deepEqual(oldValue, value)) {\n            return;\n        }\n        this._value = value;\n        this._changed.emit({\n            oldValue: oldValue,\n            newValue: value\n        });\n    }\n    /**\n     * Dispose of the resources held by the value.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this._value = null;\n    }\n}\n/**\n * The namespace for the `ObservableValue` class statics.\n */\n(function (ObservableValue) {\n    /**\n     * The changed args object emitted by the `IObservableValue`.\n     */\n    class IChangedArgs {\n    }\n    ObservableValue.IChangedArgs = IChangedArgs;\n})(ObservableValue || (ObservableValue = {}));\n/**\n * A concrete implementation of an `IModelDB`.\n */\nexport class ModelDB {\n    /**\n     * Constructor for the `ModelDB`.\n     */\n    constructor(options = {}) {\n        /**\n         * Whether the model has been populated with\n         * any model values.\n         */\n        this.isPrepopulated = false;\n        /**\n         * Whether the model is collaborative.\n         */\n        this.isCollaborative = false;\n        /**\n         * A promise resolved when the model is connected\n         * to its backend. For the in-memory ModelDB it\n         * is immediately resolved.\n         */\n        this.connected = Promise.resolve(void 0);\n        this._toDispose = false;\n        this._isDisposed = false;\n        this._disposables = new DisposableSet();\n        this._basePath = options.basePath || '';\n        if (options.baseDB) {\n            this._db = options.baseDB;\n        }\n        else {\n            this._db = new ObservableMap();\n            this._toDispose = true;\n        }\n    }\n    /**\n     * The base path for the `ModelDB`. This is prepended\n     * to all the paths that are passed in to the member\n     * functions of the object.\n     */\n    get basePath() {\n        return this._basePath;\n    }\n    /**\n     * Whether the database is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Get a value for a path.\n     *\n     * @param path: the path for the object.\n     *\n     * @returns an `IObservable`.\n     */\n    get(path) {\n        return this._db.get(this._resolvePath(path));\n    }\n    /**\n     * Whether the `IModelDB` has an object at this path.\n     *\n     * @param path: the path for the object.\n     *\n     * @returns a boolean for whether an object is at `path`.\n     */\n    has(path) {\n        return this._db.has(this._resolvePath(path));\n    }\n    /**\n     * Create a string and insert it in the database.\n     *\n     * @param path: the path for the string.\n     *\n     * @returns the string that was created.\n     */\n    createString(path) {\n        const str = new ObservableString();\n        this._disposables.add(str);\n        this.set(path, str);\n        return str;\n    }\n    /**\n     * Create an undoable list and insert it in the database.\n     *\n     * @param path: the path for the list.\n     *\n     * @returns the list that was created.\n     *\n     * #### Notes\n     * The list can only store objects that are simple\n     * JSON Objects and primitives.\n     */\n    createList(path) {\n        const vec = new ObservableUndoableList(new ObservableUndoableList.IdentitySerializer());\n        this._disposables.add(vec);\n        this.set(path, vec);\n        return vec;\n    }\n    /**\n     * Create a map and insert it in the database.\n     *\n     * @param path: the path for the map.\n     *\n     * @returns the map that was created.\n     *\n     * #### Notes\n     * The map can only store objects that are simple\n     * JSON Objects and primitives.\n     */\n    createMap(path) {\n        const map = new ObservableJSON();\n        this._disposables.add(map);\n        this.set(path, map);\n        return map;\n    }\n    /**\n     * Create an opaque value and insert it in the database.\n     *\n     * @param path: the path for the value.\n     *\n     * @returns the value that was created.\n     */\n    createValue(path) {\n        const val = new ObservableValue();\n        this._disposables.add(val);\n        this.set(path, val);\n        return val;\n    }\n    /**\n     * Get a value at a path, or `undefined if it has not been set\n     * That value must already have been created using `createValue`.\n     *\n     * @param path: the path for the value.\n     */\n    getValue(path) {\n        const val = this.get(path);\n        if (!val || val.type !== 'Value') {\n            throw Error('Can only call getValue for an ObservableValue');\n        }\n        return val.get();\n    }\n    /**\n     * Set a value at a path. That value must already have\n     * been created using `createValue`.\n     *\n     * @param path: the path for the value.\n     *\n     * @param value: the new value.\n     */\n    setValue(path, value) {\n        const val = this.get(path);\n        if (!val || val.type !== 'Value') {\n            throw Error('Can only call setValue on an ObservableValue');\n        }\n        val.set(value);\n    }\n    /**\n     * Create a view onto a subtree of the model database.\n     *\n     * @param basePath: the path for the root of the subtree.\n     *\n     * @returns an `IModelDB` with a view onto the original\n     *   `IModelDB`, with `basePath` prepended to all paths.\n     */\n    view(basePath) {\n        const view = new ModelDB({ basePath, baseDB: this });\n        this._disposables.add(view);\n        return view;\n    }\n    /**\n     * Set a value at a path. Not intended to\n     * be called by user code, instead use the\n     * `create*` factory methods.\n     *\n     * @param path: the path to set the value at.\n     *\n     * @param value: the value to set at the path.\n     */\n    set(path, value) {\n        this._db.set(this._resolvePath(path), value);\n    }\n    /**\n     * Dispose of the resources held by the database.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        if (this._toDispose) {\n            this._db.dispose();\n        }\n        this._disposables.dispose();\n    }\n    /**\n     * Compute the fully resolved path for a path argument.\n     */\n    _resolvePath(path) {\n        if (this._basePath) {\n            path = this._basePath + '.' + path;\n        }\n        return path;\n    }\n}\n//# sourceMappingURL=modeldb.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { JSONExt } from '@lumino/coreutils';\nimport { Message } from '@lumino/messaging';\nimport { ObservableMap } from './observablemap';\n/**\n * A concrete Observable map for JSON data.\n */\nexport class ObservableJSON extends ObservableMap {\n    /**\n     * Construct a new observable JSON object.\n     */\n    constructor(options = {}) {\n        super({\n            itemCmp: JSONExt.deepEqual,\n            values: options.values\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        const out = Object.create(null);\n        const keys = this.keys();\n        for (const key of keys) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                out[key] = JSONExt.deepCopy(value);\n            }\n        }\n        return out;\n    }\n}\n/**\n * The namespace for ObservableJSON static data.\n */\n(function (ObservableJSON) {\n    /**\n     * An observable JSON change message.\n     */\n    class ChangeMessage extends Message {\n        /**\n         * Create a new metadata changed message.\n         */\n        constructor(type, args) {\n            super(type);\n            this.args = args;\n        }\n    }\n    ObservableJSON.ChangeMessage = ChangeMessage;\n})(ObservableJSON || (ObservableJSON = {}));\n//# sourceMappingURL=observablejson.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, ArrayIterator, each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/**\n * A concrete implementation of [[IObservableList]].\n */\nexport class ObservableList {\n    /**\n     * Construct a new observable map.\n     */\n    constructor(options = {}) {\n        this._array = [];\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        if (options.values !== void 0) {\n            each(options.values, value => {\n                this._array.push(value);\n            });\n        }\n        this._itemCmp = options.itemCmp || Private.itemCmp;\n    }\n    /**\n     * The type of this object.\n     */\n    get type() {\n        return 'List';\n    }\n    /**\n     * A signal emitted when the list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The length of the list.\n     */\n    get length() {\n        return this._array.length;\n    }\n    /**\n     * Test whether the list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this.clear();\n    }\n    /**\n     * Create an iterator over the values in the list.\n     *\n     * @returns A new iterator starting at the front of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        return new ArrayIterator(this._array);\n    }\n    /**\n     * Get the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The value at the specified index.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._array[index];\n    }\n    /**\n     * Set the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    set(index, value) {\n        const oldValue = this._array[index];\n        if (value === undefined) {\n            throw new Error('Cannot set an undefined item');\n        }\n        // Bail if the value does not change.\n        const itemCmp = this._itemCmp;\n        if (itemCmp(oldValue, value)) {\n            return;\n        }\n        this._array[index] = value;\n        this._changed.emit({\n            type: 'set',\n            oldIndex: index,\n            newIndex: index,\n            oldValues: [oldValue],\n            newValues: [value]\n        });\n    }\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    push(value) {\n        const num = this._array.push(value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: this.length - 1,\n            oldValues: [],\n            newValues: [value]\n        });\n        return num;\n    }\n    /**\n     * Insert a value into the list at a specific index.\n     *\n     * @param index - The index at which to insert the value.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    insert(index, value) {\n        ArrayExt.insert(this._array, index, value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: index,\n            oldValues: [],\n            newValues: [value]\n        });\n    }\n    /**\n     * Remove the first occurrence of a value from the list.\n     *\n     * @param value - The value of interest.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     */\n    removeValue(value) {\n        const itemCmp = this._itemCmp;\n        const index = ArrayExt.findFirstIndex(this._array, item => {\n            return itemCmp(item, value);\n        });\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the value at a specific index.\n     *\n     * @param index - The index of the value of interest.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const value = ArrayExt.removeAt(this._array, index);\n        if (value === undefined) {\n            return;\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: index,\n            newIndex: -1,\n            newValues: [],\n            oldValues: [value]\n        });\n        return value;\n    }\n    /**\n     * Remove all values from the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        const copy = this._array.slice();\n        this._array.length = 0;\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: 0,\n            newIndex: 0,\n            newValues: [],\n            oldValues: copy\n        });\n    }\n    /**\n     * Move a value from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        if (this.length <= 1 || fromIndex === toIndex) {\n            return;\n        }\n        const values = [this._array[fromIndex]];\n        ArrayExt.move(this._array, fromIndex, toIndex);\n        this._changed.emit({\n            type: 'move',\n            oldIndex: fromIndex,\n            newIndex: toIndex,\n            oldValues: values,\n            newValues: values\n        });\n    }\n    /**\n     * Push a set of values to the back of the list.\n     *\n     * @param values - An iterable or array-like set of values to add.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    pushAll(values) {\n        const newIndex = this.length;\n        each(values, value => {\n            this._array.push(value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the list at the specified index.\n     *\n     * @param index - The index at which to insert the values.\n     *\n     * @param values - The values to insert at the specified index.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     */\n    insertAll(index, values) {\n        const newIndex = index;\n        each(values, value => {\n            ArrayExt.insert(this._array, index++, value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n    }\n    /**\n     * Remove a range of items from the list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed value and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        const oldValues = this._array.slice(startIndex, endIndex);\n        for (let i = startIndex; i < endIndex; i++) {\n            ArrayExt.removeAt(this._array, startIndex);\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: startIndex,\n            newIndex: -1,\n            oldValues,\n            newValues: []\n        });\n        return this.length;\n    }\n}\n/**\n * The namespace for module private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default strict equality item cmp.\n     */\n    function itemCmp(first, second) {\n        return first === second;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=observablelist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A concrete implementation of IObservbleMap<T>.\n */\nexport class ObservableMap {\n    /**\n     * Construct a new observable map.\n     */\n    constructor(options = {}) {\n        this._map = new Map();\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this._itemCmp = options.itemCmp || Private.itemCmp;\n        if (options.values) {\n            for (const key in options.values) {\n                this._map.set(key, options.values[key]);\n            }\n        }\n    }\n    /**\n     * The type of the Observable.\n     */\n    get type() {\n        return 'Map';\n    }\n    /**\n     * A signal emitted when the map has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Whether this map has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * The number of key-value pairs in the map.\n     */\n    get size() {\n        return this._map.size;\n    }\n    /**\n     * Set a key-value pair in the map\n     *\n     * @param key - The key to set.\n     *\n     * @param value - The value for the key.\n     *\n     * @returns the old value for the key, or undefined\n     *   if that did not exist.\n     *\n     * @throws if the new value is undefined.\n     *\n     * #### Notes\n     * This is a no-op if the value does not change.\n     */\n    set(key, value) {\n        const oldVal = this._map.get(key);\n        if (value === undefined) {\n            throw Error('Cannot set an undefined value, use remove');\n        }\n        // Bail if the value does not change.\n        const itemCmp = this._itemCmp;\n        if (oldVal !== undefined && itemCmp(oldVal, value)) {\n            return oldVal;\n        }\n        this._map.set(key, value);\n        this._changed.emit({\n            type: oldVal ? 'change' : 'add',\n            key: key,\n            oldValue: oldVal,\n            newValue: value\n        });\n        return oldVal;\n    }\n    /**\n     * Get a value for a given key.\n     *\n     * @param key - the key.\n     *\n     * @returns the value for that key.\n     */\n    get(key) {\n        return this._map.get(key);\n    }\n    /**\n     * Check whether the map has a key.\n     *\n     * @param key - the key to check.\n     *\n     * @returns `true` if the map has the key, `false` otherwise.\n     */\n    has(key) {\n        return this._map.has(key);\n    }\n    /**\n     * Get a list of the keys in the map.\n     *\n     * @returns - a list of keys.\n     */\n    keys() {\n        const keyList = [];\n        this._map.forEach((v, k) => {\n            keyList.push(k);\n        });\n        return keyList;\n    }\n    /**\n     * Get a list of the values in the map.\n     *\n     * @returns - a list of values.\n     */\n    values() {\n        const valList = [];\n        this._map.forEach((v, k) => {\n            valList.push(v);\n        });\n        return valList;\n    }\n    /**\n     * Remove a key from the map\n     *\n     * @param key - the key to remove.\n     *\n     * @returns the value of the given key,\n     *   or undefined if that does not exist.\n     *\n     * #### Notes\n     * This is a no-op if the value does not change.\n     */\n    delete(key) {\n        const oldVal = this._map.get(key);\n        const removed = this._map.delete(key);\n        if (removed) {\n            this._changed.emit({\n                type: 'remove',\n                key: key,\n                oldValue: oldVal,\n                newValue: undefined\n            });\n        }\n        return oldVal;\n    }\n    /**\n     * Set the ObservableMap to an empty map.\n     */\n    clear() {\n        // Delete one by one to emit the correct signals.\n        const keyList = this.keys();\n        for (let i = 0; i < keyList.length; i++) {\n            this.delete(keyList[i]);\n        }\n    }\n    /**\n     * Dispose of the resources held by the map.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this._map.clear();\n    }\n}\n/**\n * The namespace for module private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default strict equality item comparator.\n     */\n    function itemCmp(first, second) {\n        return first === second;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=observablemap.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nexport function convertYMapEventToMapChange(event) {\n    let changes = new Map();\n    event.changes.keys.forEach((event, key) => {\n        changes.set(key, {\n            action: event.action,\n            oldValue: event.oldValue,\n            newValue: this.ymeta.get(key)\n        });\n    });\n    return changes;\n}\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n */\nexport const createMutex = () => {\n    let token = true;\n    return (f) => {\n        if (token) {\n            token = false;\n            try {\n                f();\n            }\n            finally {\n                token = true;\n            }\n        }\n    };\n};\n//# sourceMappingURL=utils.js.map"],"sourceRoot":""}