{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/docprovider/lib/yprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/docprovider/lib/mock.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/notebook-extension/node_modules/@jupyterlab/docprovider/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/y-protocols/awareness.js"],"names":["WebSocketProviderWithLocks","options","super","url","guid","ymodel","ydoc","awareness","this","_currentLockRequest","_initialContentRequest","messageHandlers","encoder","decoder","provider","emitSynced","messageType","timestamp","decoding","lockRequest","resolve","initialContent","byteLength","setTimeout","doc","initialContentRequest","isInitialized","onConnectionStatus","bind","on","promise","reject","Promise","_resolve","_reject","_sendMessage","Uint8Array","status","lock","acquireLock","requestInitialContent","putInitializedState","releaseLock","encoding","intervalID","setInterval","wsconnected","_finally","clearInterval","then","message","send","ws","once","ProviderMock","IDocumentProviderFactory","Token","Awareness","clientID","states","Map","meta","_checkInterval","now","getLocalState","outdatedTimeout","get","lastUpdated","setLocalState","remove","forEach","clientid","has","push","length","removeAwarenessStates","destroy","emit","state","currLocalMeta","clock","undefined","prevState","delete","set","added","updated","filteredUpdated","removed","field","value","clients","origin","i","curMeta","encodeAwarenessUpdate","len","JSON","stringify","applyAwarenessUpdate","update","parse","clientMeta","currClock"],"mappings":"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","file":"9242.bundle.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\nimport * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\n/**\n * A class to provide Yjs synchronization over Websocket.\n */\nexport class WebSocketProviderWithLocks extends WebsocketProvider {\n    /**\n     * Construct a new WebSocketProviderWithLocks\n     *\n     * @param options The instantiation options for a WebSocketProviderWithLocks\n     */\n    constructor(options) {\n        super(options.url, options.guid, options.ymodel.ydoc, {\n            awareness: options.ymodel.awareness\n        });\n        this._currentLockRequest = null;\n        this._initialContentRequest = null;\n        // Message handler that confirms when a lock has been acquired\n        this.messageHandlers[127] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // acquired lock\n            const timestamp = decoding.readUint32(decoder);\n            const lockRequest = this._currentLockRequest;\n            this._currentLockRequest = null;\n            if (lockRequest) {\n                lockRequest.resolve(timestamp);\n            }\n        };\n        // Message handler that receives the initial content\n        this.messageHandlers[125] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // received initial content\n            const initialContent = decoding.readTailAsUint8Array(decoder);\n            // Apply data from server\n            if (initialContent.byteLength > 0) {\n                setTimeout(() => {\n                    Y.applyUpdate(this.doc, initialContent);\n                }, 0);\n            }\n            const initialContentRequest = this._initialContentRequest;\n            this._initialContentRequest = null;\n            if (initialContentRequest) {\n                initialContentRequest.resolve(initialContent.byteLength > 0);\n            }\n        };\n        this.isInitialized = false;\n        this.onConnectionStatus = this.onConnectionStatus.bind(this);\n        this.on('status', this.onConnectionStatus);\n    }\n    /**\n     * Resolves to true if the initial content has been initialized on the server. false otherwise.\n     */\n    requestInitialContent() {\n        if (this._initialContentRequest) {\n            return this._initialContentRequest.promise;\n        }\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._initialContentRequest = { promise, resolve, reject };\n        this._sendMessage(new Uint8Array([125]));\n        // Resolve with true if the server doesn't respond for some reason.\n        // In case of a connection problem, we don't want the user to re-initialize the window.\n        // Instead wait for y-websocket to connect to the server.\n        // @todo maybe we should reload instead..\n        setTimeout(() => resolve(false), 1000);\n        return promise;\n    }\n    async onConnectionStatus(status) {\n        if (this.isInitialized && status.status === 'connected') {\n            const lock = await this.acquireLock();\n            const contentIsInitialized = await this.requestInitialContent();\n            if (!contentIsInitialized) {\n                this.putInitializedState();\n            }\n            this.releaseLock(lock);\n        }\n    }\n    putInitializedState() {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, 124);\n        encoding.writeUint8Array(encoder, Y.encodeStateAsUpdate(this.doc));\n        this._sendMessage(encoding.toUint8Array(encoder));\n        this.isInitialized = true;\n    }\n    acquireLock() {\n        if (this._currentLockRequest) {\n            return this._currentLockRequest.promise;\n        }\n        this._sendMessage(new Uint8Array([127]));\n        // try to acquire lock in regular interval\n        const intervalID = setInterval(() => {\n            if (this.wsconnected) {\n                // try to acquire lock\n                this._sendMessage(new Uint8Array([127]));\n            }\n        }, 500);\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._currentLockRequest = { promise, resolve, reject };\n        const _finally = () => {\n            clearInterval(intervalID);\n        };\n        promise.then(_finally, _finally);\n        return promise;\n    }\n    releaseLock(lock) {\n        const encoder = encoding.createEncoder();\n        // reply with release lock\n        encoding.writeVarUint(encoder, 126);\n        encoding.writeUint32(encoder, lock);\n        // releasing lock\n        this._sendMessage(encoding.toUint8Array(encoder));\n    }\n    _sendMessage(message) {\n        // send once connected\n        const send = () => {\n            setTimeout(() => {\n                if (this.wsconnected) {\n                    this.ws.send(message);\n                }\n                else {\n                    this.once('status', send);\n                }\n            }, 0);\n        };\n        send();\n    }\n}\n//# sourceMappingURL=yprovider.js.map","export class ProviderMock {\n    requestInitialContent() {\n        return Promise.resolve(false);\n    }\n    putInitializedState() {\n        /* nop */\n    }\n    acquireLock() {\n        return Promise.resolve(0);\n    }\n    releaseLock(lock) {\n        /* nop */\n    }\n    destroy() {\n        /* nop */\n    }\n}\n//# sourceMappingURL=mock.js.map","import { Token } from '@lumino/coreutils';\n/**\n * The default document provider token.\n */\nexport const IDocumentProviderFactory = new Token('@jupyterlab/docprovider:IDocumentProviderFactory');\n//# sourceMappingURL=tokens.js.map","/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"],"sourceRoot":""}