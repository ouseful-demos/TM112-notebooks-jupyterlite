{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application-extension/node_modules/@jupyterlab/docprovider/lib/yprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application-extension/node_modules/@jupyterlab/docprovider/lib/mock.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@retrolab/application-extension/node_modules/@jupyterlab/docprovider/lib/tokens.js"],"names":["WebSocketProviderWithLocks","options","super","url","guid","ymodel","ydoc","awareness","this","_currentLockRequest","_initialContentRequest","messageHandlers","encoder","decoder","provider","emitSynced","messageType","timestamp","decoding","lockRequest","resolve","initialContent","byteLength","setTimeout","doc","initialContentRequest","isInitialized","onConnectionStatus","bind","on","promise","reject","Promise","_resolve","_reject","_sendMessage","Uint8Array","status","lock","acquireLock","requestInitialContent","putInitializedState","releaseLock","encoding","intervalID","setInterval","wsconnected","_finally","clearInterval","then","message","send","ws","once","ProviderMock","IDocumentProviderFactory","Token"],"mappings":"oRAWO,MAAMA,UAAmC,IAM5C,YAAYC,GACRC,MAAMD,EAAQE,IAAKF,EAAQG,KAAMH,EAAQI,OAAOC,KAAM,CAClDC,UAAWN,EAAQI,OAAOE,YAE9BC,KAAKC,oBAAsB,KAC3BD,KAAKE,uBAAyB,KAE9BF,KAAKG,gBAAgB,KAAO,CAACC,EAASC,EAASC,EAAUC,EAAYC,KAEjE,MAAMC,EAAYC,EAAA,GAAoBL,GAChCM,EAAcX,KAAKC,oBACzBD,KAAKC,oBAAsB,KACvBU,GACAA,EAAYC,QAAQH,IAI5BT,KAAKG,gBAAgB,KAAO,CAACC,EAASC,EAASC,EAAUC,EAAYC,KAEjE,MAAMK,EAAiBH,EAAA,GAA8BL,GAEjDQ,EAAeC,WAAa,GAC5BC,YAAW,KACP,KAAcf,KAAKgB,IAAKH,KACzB,GAEP,MAAMI,EAAwBjB,KAAKE,uBACnCF,KAAKE,uBAAyB,KAC1Be,GACAA,EAAsBL,QAAQC,EAAeC,WAAa,IAGlEd,KAAKkB,eAAgB,EACrBlB,KAAKmB,mBAAqBnB,KAAKmB,mBAAmBC,KAAKpB,MACvDA,KAAKqB,GAAG,SAAUrB,KAAKmB,oBAK3B,wBACI,GAAInB,KAAKE,uBACL,OAAOF,KAAKE,uBAAuBoB,QAEvC,IAAIV,EAASW,EACb,MAAMD,EAAU,IAAIE,SAAQ,CAACC,EAAUC,KACnCd,EAAUa,EACVF,EAASG,KASb,OAPA1B,KAAKE,uBAAyB,CAAEoB,UAASV,UAASW,UAClDvB,KAAK2B,aAAa,IAAIC,WAAW,CAAC,OAKlCb,YAAW,IAAMH,GAAQ,IAAQ,KAC1BU,EAEX,yBAAyBO,GACrB,GAAI7B,KAAKkB,eAAmC,cAAlBW,EAAOA,OAAwB,CACrD,MAAMC,QAAa9B,KAAK+B,oBACW/B,KAAKgC,yBAEpChC,KAAKiC,sBAETjC,KAAKkC,YAAYJ,IAGzB,sBACI,MAAM1B,EAAU+B,EAAA,KAChBA,EAAA,GAAsB/B,EAAS,KAC/B+B,EAAA,GAAyB/B,EAAS,KAAsBJ,KAAKgB,MAC7DhB,KAAK2B,aAAaQ,EAAA,GAAsB/B,IACxCJ,KAAKkB,eAAgB,EAEzB,cACI,GAAIlB,KAAKC,oBACL,OAAOD,KAAKC,oBAAoBqB,QAEpCtB,KAAK2B,aAAa,IAAIC,WAAW,CAAC,OAElC,MAAMQ,EAAaC,aAAY,KACvBrC,KAAKsC,aAELtC,KAAK2B,aAAa,IAAIC,WAAW,CAAC,SAEvC,KACH,IAAIhB,EAASW,EACb,MAAMD,EAAU,IAAIE,SAAQ,CAACC,EAAUC,KACnCd,EAAUa,EACVF,EAASG,KAEb1B,KAAKC,oBAAsB,CAAEqB,UAASV,UAASW,UAC/C,MAAMgB,EAAW,KACbC,cAAcJ,IAGlB,OADAd,EAAQmB,KAAKF,EAAUA,GAChBjB,EAEX,YAAYQ,GACR,MAAM1B,EAAU+B,EAAA,KAEhBA,EAAA,GAAsB/B,EAAS,KAC/B+B,EAAA,GAAqB/B,EAAS0B,GAE9B9B,KAAK2B,aAAaQ,EAAA,GAAsB/B,IAE5C,aAAasC,GAET,MAAMC,EAAO,KACT5B,YAAW,KACHf,KAAKsC,YACLtC,KAAK4C,GAAGD,KAAKD,GAGb1C,KAAK6C,KAAK,SAAUF,KAEzB,IAEPA,KCvID,MAAMG,EACT,wBACI,OAAOtB,QAAQZ,SAAQ,GAE3B,uBAGA,cACI,OAAOY,QAAQZ,QAAQ,GAE3B,YAAYkB,IAGZ,YCTG,MAAMiB,EAA2B,I,SAAIC,OAAM","file":"3338.bundle.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\nimport * as decoding from 'lib0/decoding';\nimport * as encoding from 'lib0/encoding';\n/**\n * A class to provide Yjs synchronization over Websocket.\n */\nexport class WebSocketProviderWithLocks extends WebsocketProvider {\n    /**\n     * Construct a new WebSocketProviderWithLocks\n     *\n     * @param options The instantiation options for a WebSocketProviderWithLocks\n     */\n    constructor(options) {\n        super(options.url, options.guid, options.ymodel.ydoc, {\n            awareness: options.ymodel.awareness\n        });\n        this._currentLockRequest = null;\n        this._initialContentRequest = null;\n        // Message handler that confirms when a lock has been acquired\n        this.messageHandlers[127] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // acquired lock\n            const timestamp = decoding.readUint32(decoder);\n            const lockRequest = this._currentLockRequest;\n            this._currentLockRequest = null;\n            if (lockRequest) {\n                lockRequest.resolve(timestamp);\n            }\n        };\n        // Message handler that receives the initial content\n        this.messageHandlers[125] = (encoder, decoder, provider, emitSynced, messageType) => {\n            // received initial content\n            const initialContent = decoding.readTailAsUint8Array(decoder);\n            // Apply data from server\n            if (initialContent.byteLength > 0) {\n                setTimeout(() => {\n                    Y.applyUpdate(this.doc, initialContent);\n                }, 0);\n            }\n            const initialContentRequest = this._initialContentRequest;\n            this._initialContentRequest = null;\n            if (initialContentRequest) {\n                initialContentRequest.resolve(initialContent.byteLength > 0);\n            }\n        };\n        this.isInitialized = false;\n        this.onConnectionStatus = this.onConnectionStatus.bind(this);\n        this.on('status', this.onConnectionStatus);\n    }\n    /**\n     * Resolves to true if the initial content has been initialized on the server. false otherwise.\n     */\n    requestInitialContent() {\n        if (this._initialContentRequest) {\n            return this._initialContentRequest.promise;\n        }\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._initialContentRequest = { promise, resolve, reject };\n        this._sendMessage(new Uint8Array([125]));\n        // Resolve with true if the server doesn't respond for some reason.\n        // In case of a connection problem, we don't want the user to re-initialize the window.\n        // Instead wait for y-websocket to connect to the server.\n        // @todo maybe we should reload instead..\n        setTimeout(() => resolve(false), 1000);\n        return promise;\n    }\n    async onConnectionStatus(status) {\n        if (this.isInitialized && status.status === 'connected') {\n            const lock = await this.acquireLock();\n            const contentIsInitialized = await this.requestInitialContent();\n            if (!contentIsInitialized) {\n                this.putInitializedState();\n            }\n            this.releaseLock(lock);\n        }\n    }\n    putInitializedState() {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, 124);\n        encoding.writeUint8Array(encoder, Y.encodeStateAsUpdate(this.doc));\n        this._sendMessage(encoding.toUint8Array(encoder));\n        this.isInitialized = true;\n    }\n    acquireLock() {\n        if (this._currentLockRequest) {\n            return this._currentLockRequest.promise;\n        }\n        this._sendMessage(new Uint8Array([127]));\n        // try to acquire lock in regular interval\n        const intervalID = setInterval(() => {\n            if (this.wsconnected) {\n                // try to acquire lock\n                this._sendMessage(new Uint8Array([127]));\n            }\n        }, 500);\n        let resolve, reject;\n        const promise = new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n        this._currentLockRequest = { promise, resolve, reject };\n        const _finally = () => {\n            clearInterval(intervalID);\n        };\n        promise.then(_finally, _finally);\n        return promise;\n    }\n    releaseLock(lock) {\n        const encoder = encoding.createEncoder();\n        // reply with release lock\n        encoding.writeVarUint(encoder, 126);\n        encoding.writeUint32(encoder, lock);\n        // releasing lock\n        this._sendMessage(encoding.toUint8Array(encoder));\n    }\n    _sendMessage(message) {\n        // send once connected\n        const send = () => {\n            setTimeout(() => {\n                if (this.wsconnected) {\n                    this.ws.send(message);\n                }\n                else {\n                    this.once('status', send);\n                }\n            }, 0);\n        };\n        send();\n    }\n}\n//# sourceMappingURL=yprovider.js.map","export class ProviderMock {\n    requestInitialContent() {\n        return Promise.resolve(false);\n    }\n    putInitializedState() {\n        /* nop */\n    }\n    acquireLock() {\n        return Promise.resolve(0);\n    }\n    releaseLock(lock) {\n        /* nop */\n    }\n    destroy() {\n        /* nop */\n    }\n}\n//# sourceMappingURL=mock.js.map","import { Token } from '@lumino/coreutils';\n/**\n * The default document provider token.\n */\nexport const IDocumentProviderFactory = new Token('@jupyterlab/docprovider:IDocumentProviderFactory');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}