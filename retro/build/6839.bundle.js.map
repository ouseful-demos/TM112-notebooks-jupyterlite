{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/observables/lib/observablelist.js"],"names":["Private","ObservableList","options","this","_array","_isDisposed","_changed","Signal","values","each","value","push","_itemCmp","itemCmp","length","clear","ArrayIterator","index","oldValue","undefined","Error","emit","type","oldIndex","newIndex","oldValues","newValues","num","ArrayExt","item","remove","copy","slice","fromIndex","toIndex","toArray","startIndex","endIndex","i","first","second"],"mappings":"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","file":"6839.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, ArrayIterator, each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/**\n * A concrete implementation of [[IObservableList]].\n */\nexport class ObservableList {\n    /**\n     * Construct a new observable map.\n     */\n    constructor(options = {}) {\n        this._array = [];\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        if (options.values !== void 0) {\n            each(options.values, value => {\n                this._array.push(value);\n            });\n        }\n        this._itemCmp = options.itemCmp || Private.itemCmp;\n    }\n    /**\n     * The type of this object.\n     */\n    get type() {\n        return 'List';\n    }\n    /**\n     * A signal emitted when the list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The length of the list.\n     */\n    get length() {\n        return this._array.length;\n    }\n    /**\n     * Test whether the list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this.clear();\n    }\n    /**\n     * Create an iterator over the values in the list.\n     *\n     * @returns A new iterator starting at the front of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        return new ArrayIterator(this._array);\n    }\n    /**\n     * Get the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The value at the specified index.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._array[index];\n    }\n    /**\n     * Set the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    set(index, value) {\n        const oldValue = this._array[index];\n        if (value === undefined) {\n            throw new Error('Cannot set an undefined item');\n        }\n        // Bail if the value does not change.\n        const itemCmp = this._itemCmp;\n        if (itemCmp(oldValue, value)) {\n            return;\n        }\n        this._array[index] = value;\n        this._changed.emit({\n            type: 'set',\n            oldIndex: index,\n            newIndex: index,\n            oldValues: [oldValue],\n            newValues: [value]\n        });\n    }\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    push(value) {\n        const num = this._array.push(value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: this.length - 1,\n            oldValues: [],\n            newValues: [value]\n        });\n        return num;\n    }\n    /**\n     * Insert a value into the list at a specific index.\n     *\n     * @param index - The index at which to insert the value.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    insert(index, value) {\n        ArrayExt.insert(this._array, index, value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: index,\n            oldValues: [],\n            newValues: [value]\n        });\n    }\n    /**\n     * Remove the first occurrence of a value from the list.\n     *\n     * @param value - The value of interest.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     */\n    removeValue(value) {\n        const itemCmp = this._itemCmp;\n        const index = ArrayExt.findFirstIndex(this._array, item => {\n            return itemCmp(item, value);\n        });\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the value at a specific index.\n     *\n     * @param index - The index of the value of interest.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const value = ArrayExt.removeAt(this._array, index);\n        if (value === undefined) {\n            return;\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: index,\n            newIndex: -1,\n            newValues: [],\n            oldValues: [value]\n        });\n        return value;\n    }\n    /**\n     * Remove all values from the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        const copy = this._array.slice();\n        this._array.length = 0;\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: 0,\n            newIndex: 0,\n            newValues: [],\n            oldValues: copy\n        });\n    }\n    /**\n     * Move a value from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        if (this.length <= 1 || fromIndex === toIndex) {\n            return;\n        }\n        const values = [this._array[fromIndex]];\n        ArrayExt.move(this._array, fromIndex, toIndex);\n        this._changed.emit({\n            type: 'move',\n            oldIndex: fromIndex,\n            newIndex: toIndex,\n            oldValues: values,\n            newValues: values\n        });\n    }\n    /**\n     * Push a set of values to the back of the list.\n     *\n     * @param values - An iterable or array-like set of values to add.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    pushAll(values) {\n        const newIndex = this.length;\n        each(values, value => {\n            this._array.push(value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the list at the specified index.\n     *\n     * @param index - The index at which to insert the values.\n     *\n     * @param values - The values to insert at the specified index.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     */\n    insertAll(index, values) {\n        const newIndex = index;\n        each(values, value => {\n            ArrayExt.insert(this._array, index++, value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n    }\n    /**\n     * Remove a range of items from the list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed value and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        const oldValues = this._array.slice(startIndex, endIndex);\n        for (let i = startIndex; i < endIndex; i++) {\n            ArrayExt.removeAt(this._array, startIndex);\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: startIndex,\n            newIndex: -1,\n            oldValues,\n            newValues: []\n        });\n        return this.length;\n    }\n}\n/**\n * The namespace for module private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default strict equality item cmp.\n     */\n    function itemCmp(first, second) {\n        return first === second;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=observablelist.js.map"],"sourceRoot":""}