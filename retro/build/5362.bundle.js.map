{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/logger.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/registry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/observables/lib/observablelist.js"],"names":["Private","LogOutputModel","OutputModel","options","super","this","timestamp","Date","value","level","LogConsoleModelContentFactory","LoggerOutputAreaModel","_a","maxLength","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__rest","output","add","_applyMaxLength","lastModel","Math","trunc","getTime","index","get","_maxLength","list","removeRange","Logger","_isDisposed","_contentChanged","Signal","_stateChanged","_rendermime","_version","_level","source","outputAreaModel","contentFactory","newValue","oldValue","_log","output_type","data","emit","name","log","LogLevel","type","clear","isDisposed","assign","now","LoggerRegistry","_loggers","Map","_registryChanged","_defaultRendermime","defaultRendermime","loggers","logger","rendermime","set","Array","from","values","forEach","x","dispose","ILoggerRegistry","Token","LogConsoleOutputPrompt","Widget","_timestampNode","document","createElement","node","append","_timestamp","innerHTML","toLocaleTimeString","update","dataset","logLevel","undefined","title","toLocaleString","toUpperCase","slice","LogConsoleOutputArea","model","panel","createOutputItem","prompt","widgets","msg","future","LogConsoleContentFactory","ScrollingWidget","content","_observer","addClass","layout","PanelLayout","addWidget","_content","_sentinel","appendChild","onAfterAttach","requestAnimationFrame","scrollIntoView","_scrollHeight","scrollHeight","IntersectionObserver","args","_handleScroll","root","threshold","observe","disconnect","_tracking","entry","isIntersecting","isVisible","currentHeight","LogConsolePanel","StackedPanel","loggerRegistry","translator","_outputAreas","_source","_sourceChanged","_sourceDisplayed","_loggersWatched","Set","nullTranslator","_trans","load","_loggerRegistry","registryChanged","connect","sender","_bindLoggerSignals","_placeholder","getLogger","_showOutputFromSource","_handlePlaceholder","version","_updateOutputAreas","onAfterShow","sourceVersion","getLoggers","has","contentChanged","stateChanged","change","viewId","outputArea","_b","id","parent","show","hide","__","label","caption","textContent","loggerIds","w","outputUpdate","outputLengthChanged","viewIds","keys","delete","ObservableList","_array","_changed","each","push","_itemCmp","itemCmp","ArrayIterator","Error","oldIndex","newIndex","oldValues","newValues","num","ArrayExt","item","remove","copy","fromIndex","toIndex","toArray","startIndex","endIndex","first","second"],"mappings":"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","file":"5362.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { OutputAreaModel } from '@jupyterlab/outputarea';\nimport { OutputModel } from '@jupyterlab/rendermime';\nimport { Signal } from '@lumino/signaling';\n/**\n * Log Output Model with timestamp which provides\n * item information for Output Area Model.\n */\nexport class LogOutputModel extends OutputModel {\n    /**\n     * Construct a LogOutputModel.\n     *\n     * @param options - The model initialization options.\n     */\n    constructor(options) {\n        super(options);\n        this.timestamp = new Date(options.value.timestamp);\n        this.level = options.value.level;\n    }\n}\n/**\n * Implementation of `IContentFactory` for Output Area Model\n * which creates LogOutputModel instances.\n */\nclass LogConsoleModelContentFactory extends OutputAreaModel.ContentFactory {\n    /**\n     * Create a rendermime output model from notebook output.\n     */\n    createOutputModel(options) {\n        return new LogOutputModel(options);\n    }\n}\n/**\n * Output Area Model implementation which is able to\n * limit number of outputs stored.\n */\nexport class LoggerOutputAreaModel extends OutputAreaModel {\n    constructor(_a) {\n        var { maxLength } = _a, options = __rest(_a, [\"maxLength\"]);\n        super(options);\n        this.maxLength = maxLength;\n    }\n    /**\n     * Add an output, which may be combined with previous output.\n     *\n     * @returns The total number of outputs.\n     *\n     * #### Notes\n     * The output bundle is copied. Contiguous stream outputs of the same `name`\n     * are combined. The oldest outputs are possibly removed to ensure the total\n     * number of outputs is at most `.maxLength`.\n     */\n    add(output) {\n        super.add(output);\n        this._applyMaxLength();\n        return this.length;\n    }\n    /**\n     * Whether an output should combine with the previous output.\n     *\n     * We combine if the two outputs are in the same second, which is the\n     * resolution for our time display.\n     */\n    shouldCombine(options) {\n        const { value, lastModel } = options;\n        const oldSeconds = Math.trunc(lastModel.timestamp.getTime() / 1000);\n        const newSeconds = Math.trunc(value.timestamp / 1000);\n        return oldSeconds === newSeconds;\n    }\n    /**\n     * Get an item at the specified index.\n     */\n    get(index) {\n        return super.get(index);\n    }\n    /**\n     * Maximum number of outputs to store in the model.\n     */\n    get maxLength() {\n        return this._maxLength;\n    }\n    set maxLength(value) {\n        this._maxLength = value;\n        this._applyMaxLength();\n    }\n    /**\n     * Manually apply length limit.\n     */\n    _applyMaxLength() {\n        if (this.list.length > this._maxLength) {\n            this.list.removeRange(0, this.list.length - this._maxLength);\n        }\n    }\n}\n/**\n * A concrete implementation of ILogger.\n */\nexport class Logger {\n    /**\n     * Construct a Logger.\n     *\n     * @param source - The name of the log source.\n     */\n    constructor(options) {\n        this._isDisposed = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._rendermime = null;\n        this._version = 0;\n        this._level = 'warning';\n        this.source = options.source;\n        this.outputAreaModel = new LoggerOutputAreaModel({\n            contentFactory: new LogConsoleModelContentFactory(),\n            maxLength: options.maxLength\n        });\n    }\n    /**\n     * The maximum number of outputs stored.\n     *\n     * #### Notes\n     * Oldest entries will be trimmed to ensure the length is at most\n     * `.maxLength`.\n     */\n    get maxLength() {\n        return this.outputAreaModel.maxLength;\n    }\n    set maxLength(value) {\n        this.outputAreaModel.maxLength = value;\n    }\n    /**\n     * The level of outputs logged\n     */\n    get level() {\n        return this._level;\n    }\n    set level(newValue) {\n        const oldValue = this._level;\n        if (oldValue === newValue) {\n            return;\n        }\n        this._level = newValue;\n        this._log({\n            output: {\n                output_type: 'display_data',\n                data: {\n                    'text/plain': `Log level set to ${newValue}`\n                }\n            },\n            level: 'metadata'\n        });\n        this._stateChanged.emit({ name: 'level', oldValue, newValue });\n    }\n    /**\n     * Number of outputs logged.\n     */\n    get length() {\n        return this.outputAreaModel.length;\n    }\n    /**\n     * A signal emitted when the list of log messages changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * A signal emitted when the log state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Rendermime to use when rendering outputs logged.\n     */\n    get rendermime() {\n        return this._rendermime;\n    }\n    set rendermime(value) {\n        if (value !== this._rendermime) {\n            const oldValue = this._rendermime;\n            const newValue = (this._rendermime = value);\n            this._stateChanged.emit({ name: 'rendermime', oldValue, newValue });\n        }\n    }\n    /**\n     * The number of messages that have ever been stored.\n     */\n    get version() {\n        return this._version;\n    }\n    /**\n     * Log an output to logger.\n     *\n     * @param log - The output to be logged.\n     */\n    log(log) {\n        // Filter by our current log level\n        if (Private.LogLevel[log.level] <\n            Private.LogLevel[this._level]) {\n            return;\n        }\n        let output = null;\n        switch (log.type) {\n            case 'text':\n                output = {\n                    output_type: 'display_data',\n                    data: {\n                        'text/plain': log.data\n                    }\n                };\n                break;\n            case 'html':\n                output = {\n                    output_type: 'display_data',\n                    data: {\n                        'text/html': log.data\n                    }\n                };\n                break;\n            case 'output':\n                output = log.data;\n                break;\n            default:\n                break;\n        }\n        if (output) {\n            this._log({\n                output,\n                level: log.level\n            });\n        }\n    }\n    /**\n     * Clear all outputs logged.\n     */\n    clear() {\n        this.outputAreaModel.clear(false);\n        this._contentChanged.emit('clear');\n    }\n    /**\n     * Add a checkpoint to the log.\n     */\n    checkpoint() {\n        this._log({\n            output: {\n                output_type: 'display_data',\n                data: {\n                    'text/html': '<hr/>'\n                }\n            },\n            level: 'metadata'\n        });\n    }\n    /**\n     * Whether the logger is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose the logger.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.clear();\n        this._rendermime = null;\n        Signal.clearData(this);\n    }\n    _log(options) {\n        // First, make sure our version reflects the new message so things\n        // triggering from the signals below have the correct version.\n        this._version++;\n        // Next, trigger any displays of the message\n        this.outputAreaModel.add(Object.assign(Object.assign({}, options.output), { timestamp: Date.now(), level: options.level }));\n        // Finally, tell people that the message was appended (and possibly\n        // already displayed).\n        this._contentChanged.emit('append');\n    }\n}\nvar Private;\n(function (Private) {\n    let LogLevel;\n    (function (LogLevel) {\n        LogLevel[LogLevel[\"debug\"] = 0] = \"debug\";\n        LogLevel[LogLevel[\"info\"] = 1] = \"info\";\n        LogLevel[LogLevel[\"warning\"] = 2] = \"warning\";\n        LogLevel[LogLevel[\"error\"] = 3] = \"error\";\n        LogLevel[LogLevel[\"critical\"] = 4] = \"critical\";\n        LogLevel[LogLevel[\"metadata\"] = 5] = \"metadata\";\n    })(LogLevel = Private.LogLevel || (Private.LogLevel = {}));\n})(Private || (Private = {}));\n//# sourceMappingURL=logger.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Logger } from './logger';\n/**\n * A concrete implementation of ILoggerRegistry.\n */\nexport class LoggerRegistry {\n    /**\n     * Construct a LoggerRegistry.\n     *\n     * @param defaultRendermime - Default rendermime to render outputs\n     * with when logger is not supplied with one.\n     */\n    constructor(options) {\n        this._loggers = new Map();\n        this._registryChanged = new Signal(this);\n        this._isDisposed = false;\n        this._defaultRendermime = options.defaultRendermime;\n        this._maxLength = options.maxLength;\n    }\n    /**\n     * Get the logger for the specified source.\n     *\n     * @param source - The name of the log source.\n     *\n     * @returns The logger for the specified source.\n     */\n    getLogger(source) {\n        const loggers = this._loggers;\n        let logger = loggers.get(source);\n        if (logger) {\n            return logger;\n        }\n        logger = new Logger({ source, maxLength: this.maxLength });\n        logger.rendermime = this._defaultRendermime;\n        loggers.set(source, logger);\n        this._registryChanged.emit('append');\n        return logger;\n    }\n    /**\n     * Get all loggers registered.\n     *\n     * @returns The array containing all registered loggers.\n     */\n    getLoggers() {\n        return Array.from(this._loggers.values());\n    }\n    /**\n     * A signal emitted when the logger registry changes.\n     */\n    get registryChanged() {\n        return this._registryChanged;\n    }\n    /**\n     * The max length for loggers.\n     */\n    get maxLength() {\n        return this._maxLength;\n    }\n    set maxLength(value) {\n        this._maxLength = value;\n        this._loggers.forEach(logger => {\n            logger.maxLength = value;\n        });\n    }\n    /**\n     * Whether the register is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose the registry and all loggers.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._loggers.forEach(x => x.dispose());\n        Signal.clearData(this);\n    }\n}\n//# sourceMappingURL=registry.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The Logger Registry token.\n */\nexport const ILoggerRegistry = new Token('@jupyterlab/logconsole:ILoggerRegistry');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { OutputArea } from '@jupyterlab/outputarea';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { Widget, PanelLayout, StackedPanel } from '@lumino/widgets';\nfunction toTitleCase(value) {\n    return value.length === 0 ? value : value[0].toUpperCase() + value.slice(1);\n}\n/**\n * Log console output prompt implementation\n */\nclass LogConsoleOutputPrompt extends Widget {\n    constructor() {\n        super();\n        this._timestampNode = document.createElement('div');\n        this.node.append(this._timestampNode);\n    }\n    /**\n     * Date & time when output is logged.\n     */\n    set timestamp(value) {\n        this._timestamp = value;\n        this._timestampNode.innerHTML = this._timestamp.toLocaleTimeString();\n        this.update();\n    }\n    /**\n     * Log level\n     */\n    set level(value) {\n        this._level = value;\n        this.node.dataset.logLevel = value;\n        this.update();\n    }\n    update() {\n        if (this._level !== undefined && this._timestamp !== undefined) {\n            this.node.title = `${this._timestamp.toLocaleString()}; ${toTitleCase(this._level)} level`;\n        }\n    }\n}\n/**\n * Output Area implementation displaying log outputs\n * with prompts showing log timestamps.\n */\nclass LogConsoleOutputArea extends OutputArea {\n    /**\n     * Create an output item with a prompt and actual output\n     */\n    createOutputItem(model) {\n        const panel = super.createOutputItem(model);\n        if (panel === null) {\n            // Could not render model\n            return null;\n        }\n        // first widget in panel is prompt of type LoggerOutputPrompt\n        const prompt = panel.widgets[0];\n        prompt.timestamp = model.timestamp;\n        prompt.level = model.level;\n        return panel;\n    }\n    /**\n     * Handle an input request from a kernel by doing nothing.\n     */\n    onInputRequest(msg, future) {\n        return;\n    }\n}\n/**\n * Implementation of `IContentFactory` for Output Area\n * which creates custom output prompts.\n */\nclass LogConsoleContentFactory extends OutputArea.ContentFactory {\n    /**\n     * Create the output prompt for the widget.\n     */\n    createOutputPrompt() {\n        return new LogConsoleOutputPrompt();\n    }\n}\n/**\n * Implements a panel which supports pinning the position to the end if it is\n * scrolled to the end.\n *\n * #### Notes\n * This is useful for log viewing components or chat components that append\n * elements at the end. We would like to automatically scroll when the user\n * has scrolled to the bottom, but not change the scrolling when the user has\n * changed the scroll position.\n */\nexport class ScrollingWidget extends Widget {\n    constructor(_a) {\n        var { content } = _a, options = __rest(_a, [\"content\"]);\n        super(options);\n        this._observer = null;\n        this.addClass('jp-Scrolling');\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(content);\n        this._content = content;\n        this._sentinel = document.createElement('div');\n        this.node.appendChild(this._sentinel);\n    }\n    /**\n     * The content widget.\n     */\n    get content() {\n        return this._content;\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        // defer so content gets a chance to attach first\n        requestAnimationFrame(() => {\n            this._sentinel.scrollIntoView();\n            this._scrollHeight = this.node.scrollHeight;\n        });\n        // Set up intersection observer for the sentinel\n        if (typeof IntersectionObserver !== 'undefined') {\n            this._observer = new IntersectionObserver(args => {\n                this._handleScroll(args);\n            }, { root: this.node, threshold: 1 });\n            this._observer.observe(this._sentinel);\n        }\n    }\n    onBeforeDetach(msg) {\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n    }\n    onAfterShow(msg) {\n        if (this._tracking) {\n            this._sentinel.scrollIntoView();\n        }\n    }\n    _handleScroll([entry]) {\n        if (entry.isIntersecting) {\n            this._tracking = true;\n        }\n        else if (this.isVisible) {\n            const currentHeight = this.node.scrollHeight;\n            if (currentHeight === this._scrollHeight) {\n                // Likely the user scrolled manually\n                this._tracking = false;\n            }\n            else {\n                // We assume we scrolled because our size changed, so scroll to the end.\n                this._sentinel.scrollIntoView();\n                this._scrollHeight = currentHeight;\n                this._tracking = true;\n            }\n        }\n    }\n}\n/**\n * A StackedPanel implementation that creates Output Areas\n * for each log source and activates as source is switched.\n */\nexport class LogConsolePanel extends StackedPanel {\n    /**\n     * Construct a LogConsolePanel instance.\n     *\n     * @param loggerRegistry - The logger registry that provides\n     * logs to be displayed.\n     */\n    constructor(loggerRegistry, translator) {\n        super();\n        this._outputAreas = new Map();\n        this._source = null;\n        this._sourceChanged = new Signal(this);\n        this._sourceDisplayed = new Signal(this);\n        this._loggersWatched = new Set();\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._loggerRegistry = loggerRegistry;\n        this.addClass('jp-LogConsolePanel');\n        loggerRegistry.registryChanged.connect((sender, args) => {\n            this._bindLoggerSignals();\n        }, this);\n        this._bindLoggerSignals();\n        this._placeholder = new Widget();\n        this._placeholder.addClass('jp-LogConsoleListPlaceholder');\n        this.addWidget(this._placeholder);\n    }\n    /**\n     * The logger registry providing the logs.\n     */\n    get loggerRegistry() {\n        return this._loggerRegistry;\n    }\n    /**\n     * The current logger.\n     */\n    get logger() {\n        if (this.source === null) {\n            return null;\n        }\n        return this.loggerRegistry.getLogger(this.source);\n    }\n    /**\n     * The log source displayed\n     */\n    get source() {\n        return this._source;\n    }\n    set source(name) {\n        if (name === this._source) {\n            return;\n        }\n        const oldValue = this._source;\n        const newValue = (this._source = name);\n        this._showOutputFromSource(newValue);\n        this._handlePlaceholder();\n        this._sourceChanged.emit({ oldValue, newValue, name: 'source' });\n    }\n    /**\n     * The source version displayed.\n     */\n    get sourceVersion() {\n        const source = this.source;\n        return source !== null\n            ? this._loggerRegistry.getLogger(source).version\n            : null;\n    }\n    /**\n     * Signal for source changes\n     */\n    get sourceChanged() {\n        return this._sourceChanged;\n    }\n    /**\n     * Signal for source changes\n     */\n    get sourceDisplayed() {\n        return this._sourceDisplayed;\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this._updateOutputAreas();\n        this._showOutputFromSource(this._source);\n        this._handlePlaceholder();\n    }\n    onAfterShow(msg) {\n        super.onAfterShow(msg);\n        if (this.source !== null) {\n            this._sourceDisplayed.emit({\n                source: this.source,\n                version: this.sourceVersion\n            });\n        }\n    }\n    _bindLoggerSignals() {\n        const loggers = this._loggerRegistry.getLoggers();\n        for (const logger of loggers) {\n            if (this._loggersWatched.has(logger.source)) {\n                continue;\n            }\n            logger.contentChanged.connect((sender, args) => {\n                this._updateOutputAreas();\n                this._handlePlaceholder();\n            }, this);\n            logger.stateChanged.connect((sender, change) => {\n                if (change.name !== 'rendermime') {\n                    return;\n                }\n                const viewId = `source:${sender.source}`;\n                const outputArea = this._outputAreas.get(viewId);\n                if (outputArea) {\n                    if (change.newValue) {\n                        // cast away readonly\n                        outputArea.rendermime = change.newValue;\n                    }\n                    else {\n                        outputArea.dispose();\n                    }\n                }\n            }, this);\n            this._loggersWatched.add(logger.source);\n        }\n    }\n    _showOutputFromSource(source) {\n        // If the source is null, pick a unique name so all output areas hide.\n        const viewId = source === null ? 'null source' : `source:${source}`;\n        this._outputAreas.forEach((outputArea, name) => {\n            var _a, _b;\n            // Show/hide the output area parents, the scrolling windows.\n            if (outputArea.id === viewId) {\n                (_a = outputArea.parent) === null || _a === void 0 ? void 0 : _a.show();\n                if (outputArea.isVisible) {\n                    this._sourceDisplayed.emit({\n                        source: this.source,\n                        version: this.sourceVersion\n                    });\n                }\n            }\n            else {\n                (_b = outputArea.parent) === null || _b === void 0 ? void 0 : _b.hide();\n            }\n        });\n        const title = source === null\n            ? this._trans.__('Log Console')\n            : this._trans.__('Log: %1', source);\n        this.title.label = title;\n        this.title.caption = title;\n    }\n    _handlePlaceholder() {\n        if (this.source === null) {\n            this._placeholder.node.textContent = this._trans.__('No source selected.');\n            this._placeholder.show();\n        }\n        else if (this._loggerRegistry.getLogger(this.source).length === 0) {\n            this._placeholder.node.textContent = this._trans.__('No log messages.');\n            this._placeholder.show();\n        }\n        else {\n            this._placeholder.hide();\n            this._placeholder.node.textContent = '';\n        }\n    }\n    _updateOutputAreas() {\n        const loggerIds = new Set();\n        const loggers = this._loggerRegistry.getLoggers();\n        for (const logger of loggers) {\n            const source = logger.source;\n            const viewId = `source:${source}`;\n            loggerIds.add(viewId);\n            // add view for logger if not exist\n            if (!this._outputAreas.has(viewId)) {\n                const outputArea = new LogConsoleOutputArea({\n                    rendermime: logger.rendermime,\n                    contentFactory: new LogConsoleContentFactory(),\n                    model: logger.outputAreaModel\n                });\n                outputArea.id = viewId;\n                // Attach the output area so it is visible, so the accounting\n                // functions below record the outputs actually displayed.\n                const w = new ScrollingWidget({\n                    content: outputArea\n                });\n                this.addWidget(w);\n                this._outputAreas.set(viewId, outputArea);\n                // This is where the source object is associated with the output area.\n                // We capture the source from this environment in the closure.\n                const outputUpdate = (sender) => {\n                    // If the current log console panel source is the source associated\n                    // with this output area, and the output area is visible, then emit\n                    // the logConsolePanel source displayed signal.\n                    if (this.source === source && sender.isVisible) {\n                        // We assume that the output area has been updated to the current\n                        // version of the source.\n                        this._sourceDisplayed.emit({\n                            source: this.source,\n                            version: this.sourceVersion\n                        });\n                    }\n                };\n                // Notify messages were displayed any time the output area is updated\n                // and update for any outputs rendered on construction.\n                outputArea.outputLengthChanged.connect(outputUpdate, this);\n                // Since the output area was attached above, we can rely on its\n                // visibility to account for the messages displayed.\n                outputUpdate(outputArea);\n            }\n        }\n        // remove output areas that do not have corresponding loggers anymore\n        const viewIds = this._outputAreas.keys();\n        for (const viewId of viewIds) {\n            if (!loggerIds.has(viewId)) {\n                const outputArea = this._outputAreas.get(viewId);\n                outputArea === null || outputArea === void 0 ? void 0 : outputArea.dispose();\n                this._outputAreas.delete(viewId);\n            }\n        }\n    }\n}\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, ArrayIterator, each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/**\n * A concrete implementation of [[IObservableList]].\n */\nexport class ObservableList {\n    /**\n     * Construct a new observable map.\n     */\n    constructor(options = {}) {\n        this._array = [];\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        if (options.values !== void 0) {\n            each(options.values, value => {\n                this._array.push(value);\n            });\n        }\n        this._itemCmp = options.itemCmp || Private.itemCmp;\n    }\n    /**\n     * The type of this object.\n     */\n    get type() {\n        return 'List';\n    }\n    /**\n     * A signal emitted when the list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The length of the list.\n     */\n    get length() {\n        return this._array.length;\n    }\n    /**\n     * Test whether the list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this.clear();\n    }\n    /**\n     * Create an iterator over the values in the list.\n     *\n     * @returns A new iterator starting at the front of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        return new ArrayIterator(this._array);\n    }\n    /**\n     * Get the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The value at the specified index.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._array[index];\n    }\n    /**\n     * Set the value at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    set(index, value) {\n        const oldValue = this._array[index];\n        if (value === undefined) {\n            throw new Error('Cannot set an undefined item');\n        }\n        // Bail if the value does not change.\n        const itemCmp = this._itemCmp;\n        if (itemCmp(oldValue, value)) {\n            return;\n        }\n        this._array[index] = value;\n        this._changed.emit({\n            type: 'set',\n            oldIndex: index,\n            newIndex: index,\n            oldValues: [oldValue],\n            newValues: [value]\n        });\n    }\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    push(value) {\n        const num = this._array.push(value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: this.length - 1,\n            oldValues: [],\n            newValues: [value]\n        });\n        return num;\n    }\n    /**\n     * Insert a value into the list at a specific index.\n     *\n     * @param index - The index at which to insert the value.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    insert(index, value) {\n        ArrayExt.insert(this._array, index, value);\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex: index,\n            oldValues: [],\n            newValues: [value]\n        });\n    }\n    /**\n     * Remove the first occurrence of a value from the list.\n     *\n     * @param value - The value of interest.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     */\n    removeValue(value) {\n        const itemCmp = this._itemCmp;\n        const index = ArrayExt.findFirstIndex(this._array, item => {\n            return itemCmp(item, value);\n        });\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the value at a specific index.\n     *\n     * @param index - The index of the value of interest.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed value and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const value = ArrayExt.removeAt(this._array, index);\n        if (value === undefined) {\n            return;\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: index,\n            newIndex: -1,\n            newValues: [],\n            oldValues: [value]\n        });\n        return value;\n    }\n    /**\n     * Remove all values from the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        const copy = this._array.slice();\n        this._array.length = 0;\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: 0,\n            newIndex: 0,\n            newValues: [],\n            oldValues: copy\n        });\n    }\n    /**\n     * Move a value from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        if (this.length <= 1 || fromIndex === toIndex) {\n            return;\n        }\n        const values = [this._array[fromIndex]];\n        ArrayExt.move(this._array, fromIndex, toIndex);\n        this._changed.emit({\n            type: 'move',\n            oldIndex: fromIndex,\n            newIndex: toIndex,\n            oldValues: values,\n            newValues: values\n        });\n    }\n    /**\n     * Push a set of values to the back of the list.\n     *\n     * @param values - An iterable or array-like set of values to add.\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    pushAll(values) {\n        const newIndex = this.length;\n        each(values, value => {\n            this._array.push(value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the list at the specified index.\n     *\n     * @param index - The index at which to insert the values.\n     *\n     * @param values - The values to insert at the specified index.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     */\n    insertAll(index, values) {\n        const newIndex = index;\n        each(values, value => {\n            ArrayExt.insert(this._array, index++, value);\n        });\n        this._changed.emit({\n            type: 'add',\n            oldIndex: -1,\n            newIndex,\n            oldValues: [],\n            newValues: toArray(values)\n        });\n    }\n    /**\n     * Remove a range of items from the list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed value and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        const oldValues = this._array.slice(startIndex, endIndex);\n        for (let i = startIndex; i < endIndex; i++) {\n            ArrayExt.removeAt(this._array, startIndex);\n        }\n        this._changed.emit({\n            type: 'remove',\n            oldIndex: startIndex,\n            newIndex: -1,\n            oldValues,\n            newValues: []\n        });\n        return this.length;\n    }\n}\n/**\n * The namespace for module private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default strict equality item cmp.\n     */\n    function itemCmp(first, second) {\n        return first === second;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=observablelist.js.map"],"sourceRoot":""}