{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/y-protocols/awareness.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/application-extension/lib/index.js"],"names":["Awareness","doc","super","this","clientID","states","Map","meta","_checkInterval","setInterval","now","getLocalState","outdatedTimeout","get","lastUpdated","setLocalState","remove","forEach","clientid","has","push","length","removeAwarenessStates","on","destroy","emit","clearInterval","state","currLocalMeta","clock","undefined","prevState","delete","set","added","updated","filteredUpdated","removed","field","value","awareness","clients","origin","i","curMeta","encodeAwarenessUpdate","len","encoder","JSON","stringify","applyAwarenessUpdate","update","decoder","timestamp","parse","clientMeta","currClock","CommandIDs","WebSocketProvider","options","guid","ymodel","ydoc","Promise","resolve","lock","download","id","provides","IDocumentProviderFactory","activate","app","collaborative","PageConfig","ProviderMock","autoStart","requires","ITranslator","IDocumentManager","optional","ICommandPalette","IMainMenu","translator","docManager","palette","mainMenu","trans","load","commands","shell","isEnabled","currentWidget","contextForWidget","addCommand","label","__","caption","execute","current","context","showDialog","title","body","buttons","Dialog","element","document","createElement","href","encodeURIComponent","model","toString","path","appendChild","click","removeChild","category","addItem","command","fileMenu","addGroup","TranslationManager"],"mappings":"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","file":"6356.bundle.js","sourcesContent":["/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ICommandPalette, Dialog, showDialog } from '@jupyterlab/apputils';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { IDocumentProviderFactory, ProviderMock } from '@jupyterlab/docprovider';\nimport { WebsocketProvider } from 'y-websocket';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ITranslator, TranslationManager } from '@jupyterlab/translation';\nconst YJS_WEBSOCKET_URL = 'wss://demos.yjs.dev';\nclass WebSocketProvider extends WebsocketProvider {\n    constructor(options) {\n        super(YJS_WEBSOCKET_URL, options.guid, options.ymodel.ydoc);\n    }\n    requestInitialContent() {\n        return Promise.resolve(true);\n    }\n    putInitializedState() {\n        // no-op\n    }\n    acquireLock() {\n        return Promise.resolve(0);\n    }\n    releaseLock(lock) {\n        // no-op\n    }\n}\n/**\n * The command IDs used by the application extension.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.download = 'docmanager:download';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * An alternative document provider plugin\n */\nconst docProviderPlugin = {\n    id: '@jupyterlite/application-extension:docprovider',\n    provides: IDocumentProviderFactory,\n    activate: (app) => {\n        const collaborative = PageConfig.getOption('collaborative');\n        const factory = (options) => {\n            return collaborative ? new WebSocketProvider(options) : new ProviderMock();\n        };\n        return factory;\n    }\n};\n/**\n * A plugin providing download commands in the file menu and command palette.\n */\nconst downloadPlugin = {\n    id: '@jupyterlite/application-extension:download',\n    autoStart: true,\n    requires: [ITranslator, IDocumentManager],\n    optional: [ICommandPalette, IMainMenu],\n    activate: (app, translator, docManager, palette, mainMenu) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const isEnabled = () => {\n            const { currentWidget } = shell;\n            return !!(currentWidget && docManager.contextForWidget(currentWidget));\n        };\n        commands.addCommand(CommandIDs.download, {\n            label: trans.__('Download'),\n            caption: trans.__('Download the file to your computer'),\n            isEnabled,\n            execute: () => {\n                // Checks that shell.currentWidget is valid:\n                const current = shell.currentWidget;\n                if (isEnabled() && current) {\n                    const context = docManager.contextForWidget(current);\n                    if (!context) {\n                        return showDialog({\n                            title: trans.__('Cannot Download'),\n                            body: trans.__('No context found for current widget!'),\n                            buttons: [Dialog.okButton({ label: trans.__('OK') })]\n                        });\n                    }\n                    const element = document.createElement('a');\n                    element.href = `data:text/json;charset=utf-8,${encodeURIComponent(context.model.toString())}`;\n                    element.download = context.path;\n                    document.body.appendChild(element);\n                    element.click();\n                    document.body.removeChild(element);\n                }\n            }\n        });\n        const category = trans.__('File Operations');\n        if (palette) {\n            palette.addItem({ command: CommandIDs.download, category });\n        }\n        if (mainMenu) {\n            mainMenu.fileMenu.addGroup([{ command: CommandIDs.download }], 6);\n        }\n    }\n};\n/**\n * A simplified Translator\n */\nconst translator = {\n    id: '@jupyterlite/application-extension:translator',\n    activate: (app) => {\n        const translationManager = new TranslationManager();\n        return translationManager;\n    },\n    autoStart: true,\n    provides: ITranslator\n};\nconst plugins = [\n    docProviderPlugin,\n    downloadPlugin,\n    translator\n];\nexport default plugins;\n"],"sourceRoot":""}